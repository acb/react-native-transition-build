{"version":3,"sources":["../src/Transition.js"],"names":["styles","create","container","flex","overflow","animatedContainer","position","left","top","right","bottom","uniqueId","createUniqueId","createTransition","style","animation","timing","instance","element","customStyle","customAnimation","Error","show","props","__animate","state","children","value","onTransitioned","onLayout","other","length","item","config","toValue","useNativeDriver","__animation","start","complete","newChildren","slice","shift","skipped","splice","id","forEach","itm","setState","Value","__onLayout","nativeEvent","bounds","width","layout","height","__renderElement","idx","allItems","userStyle","styler","out","in","animatedStyle","Children","only","animStyle","stop","concat","map","propTypes","isRequired","func","defaultProps","undefined"],"mappings":"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","file":"Transition.js","sourcesContent":["import React, { Component } from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { View, Animated, StyleSheet } from 'react-native';\r\n\r\n// The default transition style\r\nimport Fade from './transitions/Fade';\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    flex: 1,\r\n    overflow: 'hidden',\r\n  },\r\n  animatedContainer: {\r\n    position: 'absolute',\r\n    left: 0,\r\n    top: 0,\r\n    right: 0,\r\n    bottom: 0,\r\n  },\r\n});\r\n\r\nlet uniqueId = 0;\r\n\r\nconst createUniqueId = () => {\r\n  uniqueId += 1;\r\n  return uniqueId;\r\n};\r\n\r\nconst createTransition = (style = Fade, animation = Animated.timing) => {\r\n  let instance = null;\r\n\r\n  return class Transition extends Component {\r\n    static propTypes = {\r\n      /* A transition element requires a single Component element within it */\r\n      children: PropTypes.element.isRequired,\r\n\r\n      /* An optional function that is called, once the transition is completed */\r\n      onTransitioned: PropTypes.func,\r\n\r\n      /* An optional callback invoked when the transition has been configured */\r\n      onLayout: PropTypes.func,\r\n    };\r\n\r\n    static defaultProps = {\r\n      onTransitioned: undefined,\r\n      onLayout: undefined,\r\n    }\r\n\r\n    /**\r\n     * A helper method to run the transition to avoid using \"ref\" in\r\n     * most of the use cases. There is normally only one Transition component\r\n     * used most of the time. In such case, this method could be used to\r\n     * directly perform the transition on the last created Transition element.\r\n     * For advanced and instance specific use case, use the instance method\r\n     * instead.\r\n     *\r\n     * You can also provide a customStyle and customAnimation that will override\r\n     * the default values that were provided during createTransition for this\r\n     * one transition.\r\n     */\r\n    static show(element, customStyle = null, customAnimation = null) {\r\n      if (instance === null) {\r\n        throw new Error('No transition component rendered to show a transition');\r\n      }\r\n\r\n      // Start the transition\r\n      return instance.show(element, customStyle, customAnimation);\r\n    }\r\n\r\n    constructor(props) {\r\n      super(props);\r\n\r\n      // Store the instance on the scoped variable\r\n      instance = this;\r\n\r\n      /**\r\n       * The items that need to be transitioned to care included in the\r\n       * children state. A transition takes place to reduce the number\r\n       * of elements on the array to one.\r\n       */\r\n      this.state = {\r\n        bounds: null,\r\n        children: [{\r\n          id: createUniqueId(),\r\n          element: React.Children.only(props.children),\r\n          style,\r\n          animation,\r\n        }],\r\n        value: new Animated.Value(0),\r\n        animStyle: null,\r\n      };\r\n\r\n      this.__animation = null;\r\n    }\r\n\r\n    componentWillUnmount() {\r\n      // Stop any running animation, we don't want setState to be called\r\n      // on a unmounted component\r\n      if (this.__animation) {\r\n        this.__animation.stop();\r\n        this.__animation = null;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Instance method to run the transition. Use this method instead of\r\n     * the static helper method, if more than one Transition instance is\r\n     * expected to be created. Specially when Transition is included within\r\n     * inner views, that might be recreated with every render. Even in\r\n     * such cases, the static helper method could be used, if the method\r\n     * is not being invoked on a regular interval like via timers.\r\n     */\r\n    show(element, customStyle = null, customAnimation = null) {\r\n      const { children } = this.state;\r\n\r\n      // Add the newly added elements to the state. The render method\r\n      // has been designed to render at most 2 elements only.\r\n      const id = createUniqueId();\r\n      this.setState({\r\n        children: children.concat({\r\n          id,\r\n          element,\r\n          style: customStyle || style,\r\n          animation: customAnimation || animation,\r\n        }),\r\n      }, this.__animate);\r\n\r\n      // Update the childrens with the newly added item\r\n      return id;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the bounds of the transition layer.\r\n     * @returns Object with { width, height }. Caution, the bounds are\r\n     *          available only after the component has been attached.\r\n     */\r\n    getBounds() {\r\n      return this.state.bounds;\r\n    }\r\n\r\n    __animate = () => {\r\n      const { children, value } = this.state;\r\n      // eslint-disable-next-line no-unused-vars\r\n      const { onTransitioned, onLayout, ...other } = this.props;\r\n\r\n      // Run the animation only when there are two children not less not more\r\n      // less means, the transition is in stable state, more means new items\r\n      // have been queued, and need to run animation only after the running\r\n      // animation completes\r\n      if (children.length !== 2) {\r\n        return;\r\n      }\r\n\r\n      // The animation is defined by the incoming element\r\n      const item = children[1];\r\n\r\n      const config = Object.assign({}, other, {\r\n        toValue: 1,\r\n        useNativeDriver: false,\r\n      });\r\n\r\n      this.__animation = item.animation(value, config);\r\n      this.__animation.start((complete) => {\r\n        this.__animation = null;\r\n\r\n        // Only if the animation completes, we move further, the animation\r\n        // is incomplete only in case the component was unmounted\r\n        if (complete) {\r\n          const newChildren = this.state.children.slice();\r\n\r\n          // Remove the outgoing element\r\n          newChildren.shift();\r\n\r\n          // If any additional item has been added, transition them out\r\n          // as well, leaving out the last item\r\n          const skipped = newChildren.splice(1, newChildren.length - 2);\r\n\r\n          if (onTransitioned) {\r\n            onTransitioned(newChildren[0].id);\r\n\r\n            skipped.forEach(itm => onTransitioned(itm.id));\r\n          }\r\n\r\n          // Update the transition state, and try to run animation again\r\n          // if anything has been queued\r\n          this.setState({\r\n            children: newChildren,\r\n            value: new Animated.Value(0),\r\n          }, this.__animate);\r\n        }\r\n      });\r\n    }\r\n\r\n    __onLayout = ({ nativeEvent }) => {\r\n      this.setState({\r\n        bounds: {\r\n          width: nativeEvent.layout.width,\r\n          height: nativeEvent.layout.height,\r\n        },\r\n      }, () => this.props.onLayout && this.props.onLayout(this.state.bounds));\r\n    }\r\n\r\n    __renderElement = (item, idx, allItems) => {\r\n      // we get one null element, after the transition is completed\r\n      if (!item) {\r\n        return null;\r\n      }\r\n\r\n      // Also only render at most 2 items\r\n      if (idx > 1) {\r\n        return null;\r\n      }\r\n\r\n      const { bounds, value } = this.state;\r\n      // bounds are needed by some of the transition styles, so don't\r\n      // render as long as the onLayout has not been invoked\r\n      if (!bounds) {\r\n        return null;\r\n      }\r\n\r\n      // Get the transition style to be used, either provided during\r\n      // the transtion call or the default provided during the creation.\r\n      const userStyle = allItems.length > 1 ? allItems[1].style : item.style;\r\n\r\n      // Decide weather the incoming or the outgoing style needs to be used\r\n      // Both 'in' and 'out' styles are used for different items during the\r\n      // transition, whereas only 'out' style is used in stable state. This\r\n      // seems a bit confusing for the stable state item - but consider this\r\n      // that the stable state is the beginning of the outgoing state.\r\n      const styler = idx === 0 ? userStyle.out : userStyle.in;\r\n\r\n      const animatedStyle = styler(value, bounds, this.props);\r\n      return (\r\n        <Animated.View key={item.id} style={[styles.animatedContainer, animatedStyle]}>\r\n          {item.element}\r\n        </Animated.View>\r\n      );\r\n    }\r\n\r\n    render() {\r\n      const { children } = this.state;\r\n      return (\r\n        <View style={styles.container} onLayout={this.__onLayout}>\r\n          {children.map(this.__renderElement)}\r\n        </View>\r\n      );\r\n    }\r\n  };\r\n};\r\n\r\nexport default createTransition;\r\n"]}